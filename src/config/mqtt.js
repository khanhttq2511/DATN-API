const mqttService = require("../services/mqtt.service");
const deviceService = require("../services/device.service");
const sensorService = require("../services/sensor.service");
const roomService = require("../services/room.service");
const { sendMessageToTopic } = require('../utils');


require('dotenv').config();
const MQTT_CONFIG = {
  host: process.env.MQTT_HOST || "6550ae3976cb4c62a64fc781224785da.s1.eu.hivemq.cloud", // Broker mi·ªÖn ph√≠ ƒë·ªÉ test
  port: process.env.MQTT_PORT || 8883,
  protocol: "mqtts",
  clientId: `mqtt_${Math.random().toString(16).substr(2, 8)}`,
  username: process.env.MQTT_USERNAME, // N·∫øu c·∫ßn
  password: process.env.MQTT_PASSWORD, // N·∫øu c·∫ßn
  keepalive: 60,
  reconnectPeriod: 5000, // Th√™m t√πy ch·ªçn k·∫øt n·ªëi l·∫°i
  connectTimeout: 30000, // TƒÉng th·ªùi gian timeout
};
console.log(MQTT_CONFIG);
module.exports = MQTT_CONFIG;

const setupMQTT = (app) => {
  mqttService.connect(
    MQTT_CONFIG,
    (client) => {
      console.log("üöÄ K·∫øt n·ªëi MQTT th√†nh c√¥ng!");


      mqttService.subscribe("esp32/status", (err) => {
        if (err) {
          console.error("‚ùå L·ªói khi ƒëƒÉng k√Ω topic esp32/status:", err);
        } else {
          console.log("‚úÖ ƒêƒÉng k√Ω topic esp32/status th√†nh c√¥ng");
        }
      });

      mqttService.subscribe("devices-up", (err) => {
        if (err) {
          console.error("‚ùå L·ªói khi ƒëƒÉng k√Ω topic devices:", err);
        } else {
          console.log("‚úÖ ƒêƒÉng k√Ω topic devices-up th√†nh c√¥ng");
        }
      });

      mqttService.subscribe("esp32/automode-change-up", (err) => {
        if (err) {
          console.error("‚ùå L·ªói khi ƒëƒÉng k√Ω topic esp32/automode-change-up:", err);
        } else {
          console.log("‚úÖ ƒêƒÉng k√Ω topic esp32/automode-change-up th√†nh c√¥ng");
        }
      });

      mqttService.subscribe("connected", (err) => {
        if (err) {
          console.error("‚ùå L·ªói khi ƒëƒÉng k√Ω topic connected:", err);
        } else {
          console.log("‚úÖ ƒêƒÉng k√Ω topic connected th√†nh c√¥ng");
        }
      });

      client.on("message", async (topic, message) => {
        console.log(`üì© Nh·∫≠n message t·ª´ topic ${topic}:`, message.toString());

        if (topic === "connected") {
          const formatToPub = await deviceService.updateDeviceAfterConnected(
            message.toString()
          );
          if (!formatToPub) return;

          client.publish(message.toString(), JSON.stringify(formatToPub));
        }
        if(topic === "devices-up") {
          if (!message.toString()) return;
          
          const parsedSensorsData = JSON.parse(message.toString());
          const roomId = parsedSensorsData.roomId;
          const type = parsedSensorsData.type;
          const status = parsedSensorsData.status === true ? 'active' : 'inactive';
          const roomType = parsedSensorsData.roomType;

          await deviceService.updateDeviceStatusAfterConnected(
            roomId,
            type,
            status,
            roomType
          );
          global.io.emit('newDeviceStatus', parsedSensorsData);
          // client.publish(message.toString(), JSON.stringify(formatToPub));
        }
        if (topic === "esp32/status") {
          if (!message.toString()) return;
          const parsedSensorsData = JSON.parse(message.toString());
          const orgId = parsedSensorsData.orgId;
          const roomId = parsedSensorsData.roomId;
          const isActive = parsedSensorsData.isActive;
          const roomType = parsedSensorsData.roomType;

          // Wait for both updates to complete
          await Promise.all([
            roomService.updateRoomActive(roomId, isActive, orgId),
            deviceService.updateDeviceActive(roomId, isActive, orgId),
            sensorService.updateSensorActive(roomId, isActive, orgId)
          ]);
          
          if (isActive === true) {
            const devices = await deviceService.getAllDevicesByRoomId(roomId);
            const room = await roomService.getRoomById(orgId, roomId);
            const roommode = room.isAuto;
            for (const device of devices) {
              
                let formattoPub = {
                  roomId: device.roomId,
                  type: device.type,
                  status: device.status === 'active' ,
                  roomType: roomType
                }
                //format send topic 
                const topic = `devices-down`;
                sendMessageToTopic(topic, formattoPub);;
              
            }
            let formattoPub = {
              roomId: roomId,
              isAuto: roommode,
              orgId: orgId
            }
            const topic = `esp32/automode-change-down`;
            sendMessageToTopic(topic, formattoPub);

          }
          global.io.emit('esp32Status', "C·∫≠p nh·∫≠t tr·∫°ng th√°i esp32 th√†nh c√¥ng");
        }

        if (topic === "esp32/automode-change-up") {
          if (!message.toString()) return;
          const parsedSensorsData = JSON.parse(message.toString());
          const orgId = parsedSensorsData.orgId;
          const roomId = parsedSensorsData.roomId;
          const isAuto = parsedSensorsData.isAuto;
          // Wait for both updates to complete
          await Promise.all([
            roomService.changeAutomode(isAuto, orgId, roomId),
          ]);
          
          global.io.emit('automode-change-up', "C·∫≠p nh·∫≠t ch·∫ø ƒë·ªô esp32 th√†nh c√¥ng");
        }

      });
    },
    (error) => {
      console.error("‚ùå L·ªói khi k·∫øt n·ªëi MQTT:", error);
    }
  );

  // Set MQTT service for use in routes
  app.set("mqttService", mqttService);

  return mqttService;
};

module.exports = { setupMQTT };